<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.6" />
<title>strbuf API</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }


/*
 * xhtml11 specific
 *
 * */

tt {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

.monospaced {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([2-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>strbuf API</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>strbuf&#8217;s are meant to be used with all the usual C string and memory
APIs. Given that the length of the buffer is known, it&#8217;s often better to
use the mem* functions than a str* one (memchr vs. strchr e.g.).
Though, one has to be careful about the fact that str* functions often
stop on NULs and that strbufs may have embedded NULs.</p></div>
<div class="paragraph"><p>An strbuf is NUL terminated for convenience, but no function in the
strbuf API actually relies on the string being free of NULs.</p></div>
<div class="paragraph"><p>strbufs has some invariants that are very important to keep in mind:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
The <tt>buf</tt> member is never NULL, so it can be used in any usual C
string operations safely. strbuf&#8217;s <em>have</em> to be initialized either by
<tt>strbuf_init()</tt> or by <tt>= STRBUF_INIT</tt> before the invariants, though.
</p>
<div class="paragraph"><p>Do <strong>not</strong> assume anything on what <tt>buf</tt> really is (e.g. if it is
allocated memory or not), use <tt>strbuf_detach()</tt> to unwrap a memory
buffer from its strbuf shell in a safe way. That is the sole supported
way. This will give you a malloced buffer that you can later <tt>free()</tt>.</p></div>
<div class="paragraph"><p>However, it is totally safe to modify anything in the string pointed by
the <tt>buf</tt> member, between the indices <tt>0</tt> and <tt>len-1</tt> (inclusive).</p></div>
</li>
<li>
<p>
The <tt>buf</tt> member is a byte array that has at least <tt>len + 1</tt> bytes
  allocated. The extra byte is used to store a <tt>'\0'</tt>, allowing the
  <tt>buf</tt> member to be a valid C-string. Every strbuf function ensure this
  invariant is preserved.
</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">It is OK to "play" with the buffer directly if you work it this
      way:</td>
</tr></table>
</div>
<div class="listingblock">
<div class="content">
<pre><tt>strbuf_grow(sb, SOME_SIZE); <b>&lt;1&gt;</b>
strbuf_setlen(sb, sb-&gt;len + SOME_OTHER_SIZE);</tt></pre>
</div></div>
<div class="colist arabic"><ol>
<li>
<p>
Here, the memory array starting at <tt>sb-&gt;buf</tt>, and of length
<tt>strbuf_avail(sb)</tt> is all yours, and you can be sure that
<tt>strbuf_avail(sb)</tt> is at least <tt>SOME_SIZE</tt>.
</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content"><tt>SOME_OTHER_SIZE</tt> must be smaller or equal to <tt>strbuf_avail(sb)</tt>.</td>
</tr></table>
</div>
<div class="paragraph"><p>Doing so is safe, though if it has to be done in many places, adding the
missing API to the strbuf module is the way to go.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">Do <em>not</em> assume that the area that is yours is of size <tt>alloc
- 1</tt> even if it&#8217;s true in the current implementation. Alloc is somehow a
"private" member that should not be messed with. Use <tt>strbuf_avail()</tt>
instead.</td>
</tr></table>
</div>
</li>
</ol></div>
</li>
</ol></div>
</div>
</div>
<div class="sect1">
<h2 id="_data_structures">Data structures</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
<tt>struct strbuf</tt>
</p>
</li>
</ul></div>
<div class="paragraph"><p>This is the string buffer structure. The <tt>len</tt> member can be used to
determine the current length of the string, and <tt>buf</tt> member provides access to
the string itself.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_functions">Functions</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Life cycle
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>strbuf_init</tt>
</dt>
<dd>
<p>
        Initialize the structure. The second parameter can be zero or a bigger
        number to allocate memory, in case you want to prevent further reallocs.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_release</tt>
</dt>
<dd>
<p>
        Release a string buffer and the memory it used. You should not use the
        string buffer after using this function, unless you initialize it again.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_detach</tt>
</dt>
<dd>
<p>
        Detach the string from the strbuf and returns it; you now own the
        storage the string occupies and it is your responsibility from then on
        to release it with <tt>free(3)</tt> when you are done with it.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_attach</tt>
</dt>
<dd>
<p>
        Attach a string to a buffer. You should specify the string to attach,
        the current length of the string and the amount of allocated memory.
        The amount must be larger than the string length, because the string you
        pass is supposed to be a NUL-terminated string.  This string <em>must</em> be
        malloc()ed, and after attaching, the pointer cannot be relied upon
        anymore, and neither be free()d directly.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_swap</tt>
</dt>
<dd>
<p>
        Swap the contents of two string buffers.
</p>
</dd>
</dl></div>
</li>
<li>
<p>
Related to the size of the buffer
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>strbuf_avail</tt>
</dt>
<dd>
<p>
        Determine the amount of allocated but unused memory.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_grow</tt>
</dt>
<dd>
<p>
        Ensure that at least this amount of unused memory is available after
        <tt>len</tt>. This is used when you know a typical size for what you will add
        and want to avoid repetitive automatic resizing of the underlying buffer.
        This is never a needed operation, but can be critical for performance in
        some cases.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_setlen</tt>
</dt>
<dd>
<p>
        Set the length of the buffer to a given value. This function does <strong>not</strong>
        allocate new memory, so you should not perform a <tt>strbuf_setlen()</tt> to a
        length that is larger than <tt>len + strbuf_avail()</tt>. <tt>strbuf_setlen()</tt> is
        just meant as a <em>please fix invariants from this strbuf I just messed
        with</em>.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_reset</tt>
</dt>
<dd>
<p>
        Empty the buffer by setting the size of it to zero.
</p>
</dd>
</dl></div>
</li>
<li>
<p>
Related to the contents of the buffer
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>strbuf_rtrim</tt>
</dt>
<dd>
<p>
        Strip whitespace from the end of a string.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_cmp</tt>
</dt>
<dd>
<p>
        Compare two buffers. Returns an integer less than, equal to, or greater
        than zero if the first buffer is found, respectively, to be less than,
        to match, or be greater than the second buffer.
</p>
</dd>
</dl></div>
</li>
<li>
<p>
Adding data to the buffer
</p>
</li>
</ul></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">All of the functions in this section will grow the buffer as necessary.
If they fail for some reason other than memory shortage and the buffer hadn&#8217;t
been allocated before (i.e. the <tt>struct strbuf</tt> was set to <tt>STRBUF_INIT</tt>),
then they will free() it.</td>
</tr></table>
</div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>strbuf_addch</tt>
</dt>
<dd>
<p>
        Add a single character to the buffer.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_insert</tt>
</dt>
<dd>
<p>
        Insert data to the given position of the buffer. The remaining contents
        will be shifted, not overwritten.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_remove</tt>
</dt>
<dd>
<p>
        Remove given amount of data from a given position of the buffer.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_splice</tt>
</dt>
<dd>
<p>
        Remove the bytes between <tt>pos..pos+len</tt> and replace it with the given
        data.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_add_commented_lines</tt>
</dt>
<dd>
<p>
        Add a NUL-terminated string to the buffer. Each line will be prepended
        by a comment character and a blank.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_add</tt>
</dt>
<dd>
<p>
        Add data of given length to the buffer.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_addstr</tt>
</dt>
<dd>
<p>
Add a NUL-terminated string to the buffer.
</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">This function will <strong>always</strong> be implemented as an inline or a macro
that expands to:</td>
</tr></table>
</div>
<div class="listingblock">
<div class="content">
<pre><tt>strbuf_add(..., s, strlen(s));</tt></pre>
</div></div>
<div class="paragraph"><p>Meaning that this is efficient to write things like:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>strbuf_addstr(sb, "immediate string");</tt></pre>
</div></div>
</dd>
<dt class="hdlist1">
<tt>strbuf_addbuf</tt>
</dt>
<dd>
<p>
        Copy the contents of an other buffer at the end of the current one.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_adddup</tt>
</dt>
<dd>
<p>
        Copy part of the buffer from a given position till a given length to the
        end of the buffer.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_expand</tt>
</dt>
<dd>
<p>
        This function can be used to expand a format string containing
        placeholders. To that end, it parses the string and calls the specified
        function for every percent sign found.
</p>
<div class="paragraph"><p>The callback function is given a pointer to the character after the <tt>%</tt>
and a pointer to the struct strbuf.  It is expected to add the expanded
version of the placeholder to the strbuf, e.g. to add a newline
character if the letter <tt>n</tt> appears after a <tt>%</tt>.  The function returns
the length of the placeholder recognized and <tt>strbuf_expand()</tt> skips
over it.</p></div>
<div class="paragraph"><p>The format <tt>%%</tt> is automatically expanded to a single <tt>%</tt> as a quoting
mechanism; callers do not need to handle the <tt>%</tt> placeholder themselves,
and the callback function will not be invoked for this placeholder.</p></div>
<div class="paragraph"><p>All other characters (non-percent and not skipped ones) are copied
verbatim to the strbuf.  If the callback returned zero, meaning that the
placeholder is unknown, then the percent sign is copied, too.</p></div>
<div class="paragraph"><p>In order to facilitate caching and to make it possible to give
parameters to the callback, <tt>strbuf_expand()</tt> passes a context pointer,
which can be used by the programmer of the callback as she sees fit.</p></div>
</dd>
<dt class="hdlist1">
<tt>strbuf_expand_dict_cb</tt>
</dt>
<dd>
<p>
        Used as callback for <tt>strbuf_expand()</tt>, expects an array of
        struct strbuf_expand_dict_entry as context, i.e. pairs of
        placeholder and replacement string.  The array needs to be
        terminated by an entry with placeholder set to NULL.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_addbuf_percentquote</tt>
</dt>
<dd>
<p>
        Append the contents of one strbuf to another, quoting any
        percent signs ("%") into double-percents ("%%") in the
        destination. This is useful for literal data to be fed to either
        strbuf_expand or to the *printf family of functions.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_humanise_bytes</tt>
</dt>
<dd>
<p>
        Append the given byte size as a human-readable string (i.e. 12.23 KiB,
        3.50 MiB).
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_addf</tt>
</dt>
<dd>
<p>
        Add a formatted string to the buffer.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_commented_addf</tt>
</dt>
<dd>
<p>
        Add a formatted string prepended by a comment character and a
        blank to the buffer.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_fread</tt>
</dt>
<dd>
<p>
        Read a given size of data from a FILE* pointer to the buffer.
</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">The buffer is rewound if the read fails. If -1 is returned,
<tt>errno</tt> must be consulted, like you would do for <tt>read(3)</tt>.
<tt>strbuf_read()</tt>, <tt>strbuf_read_file()</tt> and <tt>strbuf_getline()</tt> has the
same behaviour as well.</td>
</tr></table>
</div>
</dd>
<dt class="hdlist1">
<tt>strbuf_read</tt>
</dt>
<dd>
<p>
        Read the contents of a given file descriptor. The third argument can be
        used to give a hint about the file size, to avoid reallocs.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_read_file</tt>
</dt>
<dd>
<p>
        Read the contents of a file, specified by its path. The third argument
        can be used to give a hint about the file size, to avoid reallocs.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_readlink</tt>
</dt>
<dd>
<p>
        Read the target of a symbolic link, specified by its path.  The third
        argument can be used to give a hint about the size, to avoid reallocs.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_getline</tt>
</dt>
<dd>
<p>
        Read a line from a FILE *, overwriting the existing contents
        of the strbuf. The second argument specifies the line
        terminator character, typically <tt>'\n'</tt>.
        Reading stops after the terminator or at EOF.  The terminator
        is removed from the buffer before returning.  Returns 0 unless
        there was nothing left before EOF, in which case it returns <tt>EOF</tt>.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_getwholeline</tt>
</dt>
<dd>
<p>
        Like <tt>strbuf_getline</tt>, but keeps the trailing terminator (if
        any) in the buffer.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_getwholeline_fd</tt>
</dt>
<dd>
<p>
        Like <tt>strbuf_getwholeline</tt>, but operates on a file descriptor.
        It reads one character at a time, so it is very slow.  Do not
        use it unless you need the correct position in the file
        descriptor.
</p>
</dd>
<dt class="hdlist1">
<tt>stripspace</tt>
</dt>
<dd>
<p>
        Strip whitespace from a buffer. The second parameter controls if
        comments are considered contents to be removed or not.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_split_buf</tt>
</dt>
<dt class="hdlist1">
<tt>strbuf_split_str</tt>
</dt>
<dt class="hdlist1">
<tt>strbuf_split_max</tt>
</dt>
<dt class="hdlist1">
<tt>strbuf_split</tt>
</dt>
<dd>
<p>
        Split a string or strbuf into a list of strbufs at a specified
        terminator character.  The returned substrings include the
        terminator characters.  Some of these functions take a <tt>max</tt>
        parameter, which, if positive, limits the output to that
        number of substrings.
</p>
</dd>
<dt class="hdlist1">
<tt>strbuf_list_free</tt>
</dt>
<dd>
<p>
        Free a list of strbufs (for example, the return values of the
        <tt>strbuf_split()</tt> functions).
</p>
</dd>
<dt class="hdlist1">
<tt>launch_editor</tt>
</dt>
<dd>
<p>
        Launch the user preferred editor to edit a file and fill the buffer
        with the file&#8217;s contents upon the user completing their editing. The
        third argument can be used to set the environment which the editor is
        run in. If the buffer is NULL the editor is launched as usual but the
        file&#8217;s contents are not read into the buffer upon completion.
</p>
</dd>
</dl></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2013-08-20 08:40:27 PDT
</div>
</div>
</body>
</html>
