<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.6" />
<title>run-command API</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }


/*
 * xhtml11 specific
 *
 * */

tt {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

.monospaced {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([2-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>run-command API</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>The run-command API offers a versatile tool to run sub-processes with
redirected input and output as well as with a modified environment
and an alternate current directory.</p></div>
<div class="paragraph"><p>A similar API offers the capability to run a function asynchronously,
which is primarily used to capture the output that the function
produces in the caller in order to process it.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_functions">Functions</h2>
<div class="sectionbody">
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>start_command</tt>
</dt>
<dd>
<p>
        Start a sub-process. Takes a pointer to a <tt>struct child_process</tt>
        that specifies the details and returns pipe FDs (if requested).
        See below for details.
</p>
</dd>
<dt class="hdlist1">
<tt>finish_command</tt>
</dt>
<dd>
<p>
        Wait for the completion of a sub-process that was started with
        start_command().
</p>
</dd>
<dt class="hdlist1">
<tt>run_command</tt>
</dt>
<dd>
<p>
        A convenience function that encapsulates a sequence of
        start_command() followed by finish_command(). Takes a pointer
        to a <tt>struct child_process</tt> that specifies the details.
</p>
</dd>
<dt class="hdlist1">
<tt>run_command_v_opt</tt>, <tt>run_command_v_opt_cd_env</tt>
</dt>
<dd>
<p>
        Convenience functions that encapsulate a sequence of
        start_command() followed by finish_command(). The argument argv
        specifies the program and its arguments. The argument opt is zero
        or more of the flags <tt>RUN_COMMAND_NO_STDIN</tt>, <tt>RUN_GIT_CMD</tt>,
        <tt>RUN_COMMAND_STDOUT_TO_STDERR</tt>, or <tt>RUN_SILENT_EXEC_FAILURE</tt>
        that correspond to the members .no_stdin, .git_cmd,
        .stdout_to_stderr, .silent_exec_failure of <tt>struct child_process</tt>.
        The argument dir corresponds the member .dir. The argument env
        corresponds to the member .env.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>The functions above do the following:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
If a system call failed, errno is set and -1 is returned. A diagnostic
  is printed.
</p>
</li>
<li>
<p>
If the program was not found, then -1 is returned and errno is set to
  ENOENT; a diagnostic is printed only if .silent_exec_failure is 0.
</p>
</li>
<li>
<p>
Otherwise, the program is run. If it terminates regularly, its exit
  code is returned. No diagnostic is printed, even if the exit code is
  non-zero.
</p>
</li>
<li>
<p>
If the program terminated due to a signal, then the return value is the
  signal number + 128, ie. the same value that a POSIX shell&#8217;s $? would
  report.  A diagnostic is printed.
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>start_async</tt>
</dt>
<dd>
<p>
        Run a function asynchronously. Takes a pointer to a <tt>struct
        async</tt> that specifies the details and returns a set of pipe FDs
        for communication with the function. See below for details.
</p>
</dd>
<dt class="hdlist1">
<tt>finish_async</tt>
</dt>
<dd>
<p>
        Wait for the completion of an asynchronous function that was
        started with start_async().
</p>
</dd>
<dt class="hdlist1">
<tt>run_hook</tt>
</dt>
<dd>
<p>
        Run a hook.
        The first argument is a pathname to an index file, or NULL
        if the hook uses the default index file or no index is needed.
        The second argument is the name of the hook.
        The further arguments correspond to the hook arguments.
        The last argument has to be NULL to terminate the arguments list.
        If the hook does not exist or is not executable, the return
        value will be zero.
        If it is executable, the hook will be executed and the exit
        status of the hook is returned.
        On execution, .stdout_to_stderr and .no_stdin will be set.
        (See below.)
</p>
</dd>
</dl></div>
</li>
</ol></div>
</div>
</div>
<div class="sect1">
<h2 id="_data_structures">Data structures</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
<tt>struct child_process</tt>
</p>
</li>
</ul></div>
<div class="paragraph"><p>This describes the arguments, redirections, and environment of a
command to run in a sub-process.</p></div>
<div class="paragraph"><p>The caller:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
allocates and clears (memset(&amp;chld, 0, sizeof(chld));) a
   struct child_process variable;
</p>
</li>
<li>
<p>
initializes the members;
</p>
</li>
<li>
<p>
calls start_command();
</p>
</li>
<li>
<p>
processes the data;
</p>
</li>
<li>
<p>
closes file descriptors (if necessary; see below);
</p>
</li>
<li>
<p>
calls finish_command().
</p>
</li>
</ol></div>
<div class="paragraph"><p>The .argv member is set up as an array of string pointers (NULL
terminated), of which .argv[0] is the program name to run (usually
without a path). If the command to run is a git command, set argv[0] to
the command name without the <em>git-</em> prefix and set .git_cmd = 1.</p></div>
<div class="paragraph"><p>The members .in, .out, .err are used to redirect stdin, stdout,
stderr as follows:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Specify 0 to request no special redirection. No new file descriptor
  is allocated. The child process simply inherits the channel from the
  parent.
</p>
</li>
<li>
<p>
Specify -1 to have a pipe allocated; start_command() replaces -1
  by the pipe FD in the following way:
</p>
<div class="literalblock">
<div class="content">
<pre><tt>.in: Returns the writable pipe end into which the caller writes;
        the readable end of the pipe becomes the child's stdin.</tt></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><tt>.out, .err: Returns the readable pipe end from which the caller
        reads; the writable end of the pipe end becomes child's
        stdout/stderr.</tt></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><tt>The caller of start_command() must close the so returned FDs
after it has completed reading from/writing to it!</tt></pre>
</div></div>
</li>
<li>
<p>
Specify a file descriptor &gt; 0 to be used by the child:
</p>
<div class="literalblock">
<div class="content">
<pre><tt>.in: The FD must be readable; it becomes child's stdin.
.out: The FD must be writable; it becomes child's stdout.
.err: The FD must be writable; it becomes child's stderr.</tt></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><tt>The specified FD is closed by start_command(), even if it fails to
run the sub-process!</tt></pre>
</div></div>
</li>
<li>
<p>
Special forms of redirection are available by setting these members
  to 1:
</p>
<div class="literalblock">
<div class="content">
<pre><tt>.no_stdin, .no_stdout, .no_stderr: The respective channel is
        redirected to /dev/null.</tt></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><tt>.stdout_to_stderr: stdout of the child is redirected to its
        stderr. This happens after stderr is itself redirected.
        So stdout will follow stderr to wherever it is
        redirected.</tt></pre>
</div></div>
</li>
</ol></div>
<div class="paragraph"><p>To modify the environment of the sub-process, specify an array of
string pointers (NULL terminated) in .env:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
If the string is of the form "VAR=value", i.e. it contains <em>=</em>
  the variable is added to the child process&#8217;s environment.
</p>
</li>
<li>
<p>
If the string does not contain <em>=</em>, it names an environment
  variable that will be removed from the child process&#8217;s environment.
</p>
</li>
</ol></div>
<div class="paragraph"><p>To specify a new initial working directory for the sub-process,
specify it in the .dir member.</p></div>
<div class="paragraph"><p>If the program cannot be found, the functions return -1 and set
errno to ENOENT. Normally, an error message is printed, but if
.silent_exec_failure is set to 1, no message is printed for this
special error condition.</p></div>
<div class="ulist"><ul>
<li>
<p>
<tt>struct async</tt>
</p>
</li>
</ul></div>
<div class="paragraph"><p>This describes a function to run asynchronously, whose purpose is
to produce output that the caller reads.</p></div>
<div class="paragraph"><p>The caller:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
allocates and clears (memset(&amp;asy, 0, sizeof(asy));) a
   struct async variable;
</p>
</li>
<li>
<p>
initializes .proc and .data;
</p>
</li>
<li>
<p>
calls start_async();
</p>
</li>
<li>
<p>
processes communicates with proc through .in and .out;
</p>
</li>
<li>
<p>
closes .in and .out;
</p>
</li>
<li>
<p>
calls finish_async().
</p>
</li>
</ol></div>
<div class="paragraph"><p>The members .in, .out are used to provide a set of fd&#8217;s for
communication between the caller and the callee as follows:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Specify 0 to have no file descriptor passed.  The callee will
  receive -1 in the corresponding argument.
</p>
</li>
<li>
<p>
Specify &lt; 0 to have a pipe allocated; start_async() replaces
  with the pipe FD in the following way:
</p>
<div class="literalblock">
<div class="content">
<pre><tt>.in: Returns the writable pipe end into which the caller
writes; the readable end of the pipe becomes the function's
in argument.</tt></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><tt>.out: Returns the readable pipe end from which the caller
reads; the writable end of the pipe becomes the function's
out argument.</tt></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><tt>The caller of start_async() must close the returned FDs after it
has completed reading from/writing from them.</tt></pre>
</div></div>
</li>
<li>
<p>
Specify a file descriptor &gt; 0 to be used by the function:
</p>
<div class="literalblock">
<div class="content">
<pre><tt>.in: The FD must be readable; it becomes the function's in.
.out: The FD must be writable; it becomes the function's out.</tt></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><tt>The specified FD is closed by start_async(), even if it fails to
run the function.</tt></pre>
</div></div>
</li>
</ol></div>
<div class="paragraph"><p>The function pointer in .proc has the following signature:</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>int proc(int in, int out, void *data);</tt></pre>
</div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
in, out specifies a set of file descriptors to which the function
  must read/write the data that it needs/produces.  The function
  <strong>must</strong> close these descriptors before it returns.  A descriptor
  may be -1 if the caller did not configure a descriptor for that
  direction.
</p>
</li>
<li>
<p>
data is the value that the caller has specified in the .data member
  of struct async.
</p>
</li>
<li>
<p>
The return value of the function is 0 on success and non-zero
  on failure. If the function indicates failure, finish_async() will
  report failure as well.
</p>
</li>
</ol></div>
<div class="paragraph"><p>There are serious restrictions on what the asynchronous function can do
because this facility is implemented by a thread in the same address
space on most platforms (when pthreads is available), but by a pipe to
a forked process otherwise:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
It cannot change the program&#8217;s state (global variables, environment,
  etc.) in a way that the caller notices; in other words, .in and .out
  are the only communication channels to the caller.
</p>
</li>
<li>
<p>
It must not change the program&#8217;s state that the caller of the
  facility also uses.
</p>
</li>
</ol></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2013-08-20 08:40:27 PDT
</div>
</div>
</body>
</html>
